 if (checkBtAtMode()) // checks if the arduino is in AT mode
  {
    configureBluetooth(); // If AT mode is set, configure according to the BT_xxx constants defined above
  }

  SerialA.begin(BT_BAUDRATE);    // Bluetooth and USB communications

  lastShortDataSendTime = millis(); //Give the timing a start value.



void sendData(char identifier, float value)
{
  if (!DEBUG_MODE) // Only runs if debug mode is LOW (0)
  {
    byte dataByte1;
    byte dataByte2;

    if (value == 0)
    {
      // It is impossible to send null bytes over SerialA connection
      // so instead we define zero as 0xFF or 11111111 i.e. 255
      dataByte1 = 0xFF;
      dataByte2 = 0xFF;

    }
    else if (value <= 127)
    {
      // Values under 128 are sent as a float
      // i.e. value = dataByte1 + dataByte2 / 100
      int integer;
      int decimal;
      float tempDecimal;

      integer = (int) value;
      tempDecimal = (value - (float) integer) * 100;
      decimal = (int) tempDecimal;

      dataByte1 = (byte) integer;
      dataByte2 = (byte) decimal;

      if (decimal == 0)
      {
        dataByte2 = 0xFF;
      }

      if (integer == 0)
      {
        dataByte1 = 0xFF;
      }

    }
    else
    {
      // Values above 127 are sent as integer
      // i.e. value = dataByte1 * 100 + dataByte2
      int tens;
      int hundreds;

      hundreds = (int)(value / 100);
      tens = value - hundreds * 100;

      dataByte1 = (byte)hundreds;
      //dataByte1 = dataByte1 || 0x10000000; //flag for integer send value
      dataByte1 += 128;
      dataByte2 = (byte) tens;

      if (tens == 0)
      {
        dataByte2 = 0xFF;
      }

      if (hundreds == 0)
      {
        dataByte1 = 0xFF;
      }
    }

    // Send the data in the format { [id] [1] [2] }
    SerialA.write(123);
    SerialA.write(identifier);
    SerialA.write(dataByte1);
    SerialA.write(dataByte2);
    SerialA.write(125);

  }

}

/** override for integer values*/
void sendData(char identifier, int value)
{
  if (!DEBUG_MODE)
  {
    byte dataByte1;
    byte dataByte2;

    if (value == 0)
    {
      dataByte1 = 0xFF;
      dataByte2 = 0xFF;

    }
    else if (value <= 127)
    {

      dataByte1 = (byte)value;
      dataByte2 = 0xFF; //we know there's no decimal component as an int was passed in
    }
    else
    {
      int tens;
      int hundreds;

      hundreds = (int)(value / 100);
      tens = value - hundreds * 100;

      dataByte1 = (byte)hundreds;
      dataByte1 += 128;   //sets MSB High to indicate Integer value
      dataByte2 = (byte) tens;

      if (tens == 0)
      {
        dataByte2 = 0xFF;
      }

      if (hundreds == 0)
      {
        dataByte1 = 0xFF;
      }
    }

    SerialA.write(123);
    SerialA.write(identifier);
    SerialA.write(dataByte1);
    SerialA.write(dataByte2);
    SerialA.write(125);
  }

}


/** ================================== */
/** HC-05 CONFIGURATION FUNCTIONS      */
/** ================================== */


int checkBtAtMode() //Checks if the HC-05 Bluetooth module is in AT mode. Returns 1 if it is, 0 otherwise
{

  int atMode = 0;

  SerialA.begin(38400); //AT mode baud rate

  while(!SerialA){} //Wait for serialA to initialise

  delay(200);

  SerialA.print("AT\r\n"); // for some reason when AT is sent the first time, an error is always returned.

  delay(200); //wait for response

  //    SerialA.flush(); // Flush the response to the first AT query
  flushSerialA();

  while (SerialA.available()) // to check if the flush worked
  {
    SerialA.println((char)SerialA.read());
  }

  //SerialA.println("End of flush check");
  SerialA.println("AT");

  delay(200);

  char tempOne = (char)SerialA.read();
  delay(20);
  char tempTwo = (char)SerialA.read();

  if (tempOne == 'O' && tempTwo == 'K') //Was the response "OK"?
  {
    //    SerialA.println("AT Mode Confirmed");
    digitalWrite(13, HIGH);
    atMode = 1;
  }
  else
  {
    //    SerialA.println("AT Mode NOT Confirmed");
    //    SerialA.print("Char 1 = ");
    //    SerialA.print(tempOne);
    //    SerialA.print("Char 2 = ");
    //    SerialA.println(tempTwo);

  }

  SerialA.begin(BT_BAUDRATE); //reset baud rate
  while (!SerialA) {} //wait while serialA is inialising

  return (atMode);
}


void configureBluetooth()
{
  //Assumes AT mode has been confirmed.

  SerialA.begin(38400);

  uint8_t btNameSet = 0; //These will be set to 1 when each is successfully updated
  uint8_t btBaudSet = 0;
  uint8_t btPasswordSet = 0;

  //Set Bluetooth Name

  flushSerialA();// Flush the buffer. Not entirely sure what is in there to flush at this point, but it is needed!
  SerialA.print("AT+NAME=");
  SerialA.print(BT_NAME);
  SerialA.print("\r\n");

  //Now Check Response

  waitForSerialA(500);

  char tempOne = (char)SerialA.read();

  waitForSerialA(500);

  char tempTwo = (char)SerialA.read();


  if (tempOne == 'O' && tempTwo == 'K') //Was the response "OK"?
  {
    SerialA.println("Name Set");
    btNameSet = 1;
  }
  else
  {
    SerialA.println("Name Not Set");
    SerialA.print("Char 1 = ");
    SerialA.println(tempOne);
    SerialA.print("Char 2 = ");
    SerialA.print(tempTwo);
    SerialA.print("\r\n");
  }

  //Set Baud Rate_____________________________________________
  delay(100);
  //SerialA.flush();
  flushSerialA();
  SerialA.print("AT+UART="); //command to change BAUD rate
  SerialA.print(BT_BAUDRATE); // overflowed when baud rate was an int
  //SerialA.print(115200); //Convert the integer constant baud rate into a string BT_BAUDRATE
  SerialA.println(",0,0"); //Parity and Stop bits

  //Now Check Response.

  waitForSerialA(500);

  tempOne = (char)SerialA.read();

  waitForSerialA(500);

  tempTwo = (char)SerialA.read();


  if (tempOne == 'O' && tempTwo == 'K') //Was the response "OK"?
  {
    SerialA.println("Baud Rate Set");
    btBaudSet = 1;
  }
  else
  {
    SerialA.println("Baud Rate Not Set");
    SerialA.print("Char 1 = ");
    SerialA.println(tempOne);
    SerialA.print("Char 2 = ");
    SerialA.println(tempTwo);
  }



if (btBaudSet && btNameSet)// && btPasswordSet)
  {
    flushSerialA();
    digitalWrite(13, HIGH);
    delay(200);
    digitalWrite(13, LOW);
    delay(200);
    digitalWrite(13, HIGH);
    delay(200);
    digitalWrite(13, LOW);
    delay(200);
    SerialA.println("AT+RESET\r\n"); // has to be in the middle to provide a suitable delay before and after
    digitalWrite(13, HIGH);
    delay(200);
    digitalWrite(13, LOW);
    delay(200);
    digitalWrite(13, HIGH);
    delay(200);
    digitalWrite(13, LOW);
    delay(200);

  }
  else
  {
    int flashCount = 0;
    while (flashCount < 10) //10 fast flashes indicate not configured successfully
    {
      digitalWrite(13, HIGH);
      delay(50);
      digitalWrite(13, LOW);
      delay(50);
      flashCount ++;
    }
  }

  SerialA.begin(BT_BAUDRATE);
}


void flushSerialA()
{
  while (SerialA.available())
  {
    char temp = SerialA.read();
  }
}

void waitForSerialA(int timeOut)
{
  long tempTime = millis() + timeOut;

  while (!SerialA.available() && millis() < tempTime)
  {} //Do nothing - i.e. wait until serialA becomes availble or the timeout is reached.
}

/** ================================== */
/** INTERRUPT SERVICE ROUTINES         */
/** ================================== */

/** This function is triggered every time the magnet on the motor shaft passes the Hall effect
 *  sensor. Care must be taken to ensure the sensor is position the correct way and so is the
 *  magnet as it will only respond in a specific orientation and magnet pole.
 *
 *  It is best practice to keep ISRs as small as possible.
 */
void motorSpeedISR()
{
  motorPoll++;
}

void wheelSpeedISR()
{
  wheelPoll++;
}




